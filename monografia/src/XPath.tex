\chapter{XPath e XPath Injection}
Uma das aplicações mais comuns do XML é o armazenamento de dados de forma estruturada e legível, tanto para máquinas como para humanos.

Já existem tecnologias que permitem pegar os dados armazenados em um documento e convertê-los para outra representação, como uma página web ou um documento PDF, tecnologias que permitem que um documento XML referencie outro, tecnologias que garantam a autenticidade de um documento XML, como uma assinatura digital, e tecnologias que ajudam a navegar pelo documento XML. Esta última é conhecida como XPath.

\section{Entendendo o XPath}
Em uma consulta XPath, o documento XML é visto como uma árvore, onde cada tag, cada atributo, cada texto, cada comentário, etc. é tratado como um nó. A linguagem XPath permite navegar por essa árvore, selecionando um conjunto de nós baseado em uma série de critérios. Desde 1999, XPath é uma recomendação da W3C\cite{W3Schools:XPath}.

As principais expressões no XPath são:
\begin{table}
 \caption{Principais expressões XPath}
 \label{tab:expressoes-xpath}
 
 \begin{tabular}{lp{11cm}}
  \toprule
  \textbf{Expressão} & \textbf{Descrição} \\
  \midrule
  \textit{nome} & Seleciona todos os filhos com o nome dado \\
  \midrule
  / & Seleciona a partir do nó atual \\
  \midrule
  // & Seleciona todos os nós do documento que satisfaçam o critério, partindo do atual \\
  \midrule
  . & Seleciona o nó atual \\
  \midrule
  .. & Seleciona o pai do nó atual \\
  \midrule
  @ & Seleciona um atributo \\
  \bottomrule
 \end{tabular}
\end{table}

O seguinte documento XML é utilizado para verificar os valores máximos de cotações de compra que um usuário pode aprovar:
\begin{lstlisting}[language=XML]
<?xml version="1.0" encoding="iso-8859-1"?>
<VALCOMPRAS>
  <VALOR VALUE="500" NUMCOT="1">
    <USERS>
      <USER NAME="EMILY"/>
    </USERS>
  </VALOR>
  <VALOR VALUE="999" NUMCOT="1">
    <USERS>
      <USER NAME="TANIA"/>
    </USERS>
  </VALOR>
  <VALOR VALUE="1000000" NUMCOT="1">
    <USERS>
      <USER NAME="CHRISTIAN"/>
    </USERS>
  </VALOR>
</VALCOMPRAS>
\end{lstlisting}

A estão algumas consultas XPath aplicadas nesse documento, e se seus resultados:
\begin{description*}
  \item[VALCOMPRAS] Seleciona todos os filhos do elemento raiz (VALCOMPRAS)
  \item[/VALCOMPRAS] Seleciona o elemento raiz
  \item[VALCOMPRAS/VALOR] Seleciona todos os elementos \texttt{VALOR} filhos diretos de \texttt{VALCOMPRAS}
  \item[VALCOMPRAS//USER] Seleciona todos os elementos \texttt{USER} descendentes de \texttt{VALCOMPRAS}. Não é necessário ser um filho direto
  \item[//@VALUE] Seleciona todos os atributos \texttt{VALUE} do documento 
\end{description*}

Para filtrar nós, faz-se o uso de predicados, expressões entre colchetes. A seguir estão alguns exemplos de consultas com predicados e seus resultados:
\begin{description*}
	\item[VALCOMPRAS/VALOR[1]]\\
	  Seleciona o primeiro elemento \texttt{VALOR} filho de \texttt{VALCOMPRAS}
	\item[VALCOMPRAS/VALOR[last()]]\\
	  Seleciona o último elemento \texttt{VALOR} filho de \texttt{VALCOMPRAS}
	\item[VALCOMPRAS/VALOR[position() <= 2]]\\
	  Seleciona os dois primeiros elementos \texttt{VALOR} filhos de \texttt{VALCOMPRAS}
  \item[//VALOR[@VALUE]]\\
    Seleciona todos os elementos \texttt{VALOR} que possuam um atributo \texttt{VALUE}
  \item[//USERS[USER]]\\
    Seleciona todos os elementos \texttt{USERS} que tenham uma tag \texttt{USER} como filho
  \item[VALCOMPRAS/VALOR[@VALUE >= 1000]//USER]]\\
    Seleciona todos os elementos \texttt{USER} que descendentes de um elemento \texttt{VALOR} com o atributo VALUE maior ou igual a 1000 
\end{description*}

\section{XPath Injection}
Além de transferir dados em formato XML, muitos desenvolvedores de web services optam por armazenar alguns dados internamente em documentos XML. Utilizando este formato, ao receber uma requisição, é realizada uma consulta Xpath sobre esses documentos utilizando os parâmetros passados, retornando obtendo a resposta desejada.

O código a seguir, escrito em C\# mostra esse comportamento em um web service que consulta um documento XML parecido com o do exemplo anterior:
\begin{lstlisting}[language=C++]
XmlDocument doc = new XmlDocument();
doc.Load(ConfigurationManager.AppSettings["aprovval.xml"]);
var n= doc.SelectNodes("//VALOR[@VALUE >=" + valor + "]/USERS/USER/@NAME");

var sb = new StringBuilder();

for (int i = 0; i < n.Count; i++)
{
  string s = n.Item(i).Value + ';';
  if(!sb.ToString().Contains(s))
  sb.Append(s);
}
ViewBag.Usuarios = sb.ToString();
return View();
\end{lstlisting}

Na linha 3, é realizada uma consulta XPath baseada em um parâmetro para o Web Service. A ideia dessa consulta é obter todos os nomes de usuário que podem aprovar cotações de determinado valor. Supondo que a cotação de compras seja de R\$1000, essa consulta ficaria como:
\begin{lstlisting}[numbers=none]
//VALOR[@VALUE >= 1000]/USERS/USER/@NAME
\end{lstlisting}
o que retorna a lista de nomes corretamente.

Se este parâmetro \texttt{valor} tiver o formato de uma consulta XPath, é possível retornar usuários que não tenham permissão para aprovar este valor. Por exemplo, se o parâmetro tiver o formato \texttt{1000 | USERS}, a consulta ficaria como:
\begin{lstlisting}[numbers=none]
 //VALOR[@VALUE >= 1000 | USERS]/USERS/USER/@NAME
\end{lstlisting}
retornando os nomes de todos os usuários no documento, independente do valor permitido. Da mesma forma, se a consulta realizada tiver o formado
\begin{lstlisting}[numbers=none]
 //VALOR[@VALUE >= 1000 | //@NAME="EMILY"]/USERS/USER/@NAME
\end{lstlisting}
o nome do usuário EMILY será retornado independente do valor da cotação.

A esse tipo de manipulação da consulta realizada no documento XML é dado o nome \emph{XPath Injection}.